{
  "courses": {
    "avalanche-fundamentals": {
      "title": "Avalanche Fundamentals",
      "quizzes": ["101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117"]
    },
    "l1-tokenomics": {
      "title": "L1 Tokenomics",
      "quizzes": ["201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215"]
    },
    "interchain-token-transfer": {
      "title": "Interchain Token Transfer",
      "quizzes": ["118", "119", "120", "121", "122", "123", "124", "125", "126", "127"]
    },
    "interchain-messaging": {
      "title": "Interchain Messaging",
      "quizzes": ["301", "302", "303", "304", "305", "306", "307", "308", "309", "310", "311", "312", "313", "314", "315", "316"]
    },
    "multichain-architecture": {
      "title": "Multichain Architecture",
      "quizzes": ["401", "402", "403", "404", "405", "406", "407", "408", "409", "410"]
    }
    },
    "quizzes": {
    "101": {
      "question": "What is the underlying principle of the Avalanche Consensus family?",
      "options": [
        "Repeated Sub-Sampling",
        "Centralized Election",
        "Randomly choosing a Validator that decides on the next State",
        "Proof of Work"
      ],
      "correctAnswers": [0],
      "hint": "Think about how Avalanche Consensus achieves consensus.",
      "explanation": "The underlying principle of the Avalanche Consensus family is Repeated Sub-Sampling. This means that validators repeatedly sample the network to reach consensus.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "102": {
      "question": "What is the role of validators in the event of conflicting transactions?",
      "options": [
        "Validators choose the transaction that benefits them the most.",
        "Validators automatically reject all conflicting transactions.",
        "Validators collectively decide on which of the two conflicting transactions will be accepted by all validators and determine the next state.",
        "Validators create a new transaction to resolve the conflict."
      ],
      "correctAnswers": [2],
      "hint": "Think about how validators resolve conflicts in a blockchain network.",
      "explanation": "In the event of conflicting transactions, validators have to collectively decide on which of the two conflicting transactions will be accepted by all validators and determine the next state. They do not act based on personal benefits, they don't reject all conflicting transactions, and they don't create new transactions to resolve conflicts.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "103": {
      "question": "What is a Double Spending Attack in the context of blockchain?",
      "options": [
        "It is when a user attempts to spend more cryptocurrency than they own by creating multiple transactions that reference the same funds.",
        "It is when a user tries to double the amount of cryptocurrency they own through fraudulent transactions.",
        "It is when a user performs two transactions at the exact same time to exploit the system.",
        "It is when a validator duplicates transactions to increase their validation rewards."
      ],
      "correctAnswers": [0],
      "hint": "Think about how a user would attempt to spend more funds than they hold.",
      "explanation": "A Double Spending Attack is when a user attempts to spend more cryptocurrency than they own by creating multiple transactions that reference the same funds. This kind of attack is a threat to the integrity of the blockchain system.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "104": {
      "question": "In the Avalanche Consensus protocol, what determines whether a validator changes its preference?",
      "options": [
        "A simple majority of sampled validators",
        "An α-majority of sampled validators",
        "A unanimous decision from sampled validators",
        "The validator's initial random choice"
      ],
      "correctAnswers": [1],
      "hint": "Think about the concept of 'α-majority' mentioned in the chapter.",
      "explanation": "Avalanche consensus dictates that a validator changes its preference if an α-majority of the sampled validators agrees on another option. The α-majority is a key concept in the protocol, allowing for flexible decision-making based on the sampled subset of validators.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "105": {
      "question": "When does a validator in Avalanche finalize its decision?",
      "options": [
        "After a set number of rounds of querying and getting majority consensus.",
        "After the preference is confirmed by the α-majority for β (Decision Threshold) consecutive rounds.",
        "As soon as a conflict between transactions arises.",
        "When all validators in the system have replied with their preference."
      ],
      "correctAnswers": [1],
      "hint": "Think about the process of finalizing a decision in Avalanche Consensus.",
      "explanation": "In Avalanche, a validator finalizes its decision after its preference is confirmed by the α-majority for β (Decision Threshold) consecutive rounds. It's not a single round process, it doesn't happen immediately when a conflict arises, and it doesn't require replies from all validators in the system.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "106": {
      "question": "What is the primary purpose of an L1 within the Avalanche network?",
      "options": [
        "Increasing token value",
        "Mining cryptocurrency",
        "Enabling specialized blockchain use cases"
      ],
      "correctAnswers": [2],
      "hint": "Think about how L1s are designed to be customizable and optimized for specific use cases.",
      "explanation": "The primary purpose of an L1 within the Avalanche network is to enable specialized blockchain use cases. Each L1 is designed to be optimized for specific use cases, thereby boosting the network's overall performance.",
      "chapter": "Multi-Chain Architecture"
    },
    "107": {
      "question": "The addition of a new decentralized application (dApp) on a single-chain system causes more competition over the block space of that chain.",
      "options": [
        "True",
        "False"
      ],
      "correctAnswers": [0],
      "hint": "Think about how each new dApp vies for the same block space in a single-chain system.",
      "explanation": "Each new dApp vies for the same block space in a single-chain system, leading to unnecessary overcrowding of the chain. Multi-chain systems alleviate this issue.",
      "chapter": "Multi-Chain Architecture"
    },
    "108": {
      "question": "In case of a security breach on the Ethereum mainnet, all Layer 2 solutions are potentially affected.",
      "options": [
        "True",
        "False"
      ],
      "correctAnswers": [0],
      "hint": "Think about how Layer 2 solutions delegate security to the Ethereum mainnet.",
      "explanation": "Layer 2 solutions delegate security to the Ethereum mainnet. Hence, a security breach on the mainnet could potentially affect all Layer 2 solutions.",
      "chapter": "Multi-Chain Architecture"
    },
    "109": {
      "question": "In the soda dispenser analogy, what does the 'state' of the machine represent? (Select all that apply)",
      "options": [
        "The soda flavors",
        "The current balance",
        "The number of cans available per flavor",
        "The location of the machine"
      ],
      "correctAnswers": [1, 2],
      "hint": "Think about what information the machine needs to keep track of to function properly.",
      "explanation": "In the soda dispenser analogy, the 'state' of the machine represents the current balance, total revenue, and the number of cans available per brand.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "110": {
      "question": "In the soda dispenser analogy, what of the following are operations of the machine? (Select all that apply)",
      "options": [
        "Inserting coins",
        "The current balance",
        "The location of the machine",
        "Selecting a soda flavour"
      ],
      "correctAnswers": [0, 3],
      "hint": "Think about what actions a user can take when interacting with the machine.",
      "explanation": "In the soda dispenser analogy, the operations of the machine include inserting coins and selecting a soda flavor.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "111": {
      "question": "What are the advantages of implementing state machines? (Select all that apply)",
      "options": [
        "Increased network speed",
        "Decreased transaction costs",
        "Reproducibility",
        "Clear interface"
      ],
      "correctAnswers": [2, 3],
      "hint": "Think about how state machines simplify interactions and ensure consistency.",
      "explanation": "State machines, like the virtual machines in a blockchain, have a clear interface that makes it straightforward to interact with them. They are also reproducible, meaning multiple identical instances can be created.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "112": {
      "question": "In blockchain systems, what role do validators play? (Select all that apply)",
      "options": [
        "They reach consensus on the sequence in which transactions are carried out",
        "They determine the prices of the digital assets",
        "They regulate the blockchain's electricity usage",
        "They operate one or more instances of the virtual machines"
      ],
      "correctAnswers": [0, 3],
      "hint": "Think about the role validators play in maintaining the blockchain's integrity.",
      "explanation": "Validators in blockchain systems operate one or more instances of virtual machines and reach consensus on the sequence in which transactions are carried out.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "113": {
      "question": "How do the validators make sure that they all have the same view on the state?",
      "options": [
        "By assigning each validator a unique part of the blockchain to monitor",
        "Through the execution of operations on the local instance of the VM by all validators in the same order",
        "Through the manual checking of each transaction by a centralized authority"
      ],
      "correctAnswers": [1],
      "hint": "Think about how validators ensure that they all have the same view of the blockchain's state.",
      "explanation": "Validators ensure they all have the same view on the state by executing operations on their local instance of the VM in the same order. This ensures consistency across the network.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "114": {
      "question": "What is a Virtual Machine (VM) in the context of blockchain?",
      "options": [
        "A decentralized computer that can execute a program in a controlled environment",
        "A physical machine that runs a blockchain network",
        "A machine that dispenses soda"
      ],
      "correctAnswers": [0],
      "hint": "Think about how a VM operates in a blockchain system.",
      "explanation": "A Virtual Machine (VM) in the context of blockchain is like a decentralized computer that can execute a program in a controlled environment. It defines the application-level logic of a blockchain.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "115": {
      "question": "How many VMs can Avalanche run?",
      "options": [
        "Only the Avalanche Virtual Machine",
        "EVM and AVM",
        "There is no limit to how many virtual machines can run on Avalanche. Everyone can create a modified VM catering best to their needs"
      ],
      "correctAnswers": [2],
      "hint": "Think about the flexibility of Avalanche's architecture.",
      "explanation": "Avalanche is designed to be highly flexible, allowing for an unlimited number of custom Virtual Machines to be created and run on the network.",
      "chapter": "Virtual Machine Customization"
    },
    "116": {
      "question": "Can a Virtual Machine (VM) be used to create multiple blockchains?",
      "options": [
        "Yes, the same VM can be used to create multiple blockchains",
        "No, each blockchain requires a unique VM",
        "Yes, but only if the blockchains are part of different networks"
      ],
      "correctAnswers": [0],
      "hint": "Think about how a VM can be customized to create different blockchains.",
      "explanation": "You can think of a Virtual Machine (VM) as a blueprint for a blockchain, where the same VM can be used to create multiple blockchains. Each of these blockchains adheres to the same rules but remains logically independent from the others.",
      "chapter": "Virtual Machine Customization"
    },
    "117": {
      "question": "How does Avalanche handle the modification of Virtual Machines (VMs)?",
      "options": [
        "Customization is challenging and requires a wide consensus among network participants.",
        "Customization is not allowed as it can compromise the security of the blockchain.",
        "Avalanche offers an easy API for VM developers.",
        "Avalanche does not support customization of VMs."
      ],
      "correctAnswers": [2],
      "hint": "Think about how Avalanche allows developers to modify Virtual Machines.",
      "explanation": "Unlike one-chain-fits all systems, which requires a wide consensus to make changes, Avalanche allows for straightforward customization of Virtual Machines, making it more adaptable to unique use cases.",
      "chapter": "Virtual Machine Customization"
    },
    "118": {
      "question": "Which of the following best describes the role of a native token in an EVM-based blockchain?",
      "options": [
        "It is used only for staking and governance within the blockchain.",
        "It serves as both a means of value transfer and as the gas token for executing transactions and smart contracts.",
        "It is used exclusively for purchasing NFTs on the blockchain.",
        "It has no functional role other than being a store of value."
      ],
      "correctAnswers": [1],
      "hint": "Consider both value transfer and execution costs in the network.",
      "explanation": "In an EVM-based blockchain, the native token serves as both a means of value transfer within the network and as the gas token for executing transfers or smart contracts. Some blockchains optionally choose to also use the native token as their staking and governance token.",
      "chapter": "Interchain Token Transfer"
    },
    "119": {
      "question": "What is the purpose of marking a function as 'payable' in Solidity?",
      "options": [
        "It allows the function to receive ERC-20 tokens.",
        "It enables the function to execute without gas fees.",
        "It allows the function to receive native blockchain tokens.",
        "It prevents the function from modifying state variables."
      ],
      "correctAnswers": [2],
      "hint": "Think about how functions handle incoming funds.",
      "explanation": "In Solidity, marking a function as 'payable' allows it to accept native blockchain tokens like ETH or AVAX. Without 'payable', the function cannot receive native tokens.",
      "chapter": "Interchain Token Transfer"
    },
    "120": {
      "question": "What is the purpose of the `approve()` function in the ERC-20 token standard?",
      "options": [
        "It allows an address to transfer tokens to another address directly.",
        "It grants an allowance for another account to spend the balance of an account.",
        "It returns the total supply of the token.",
        "It checks the balance of a specific address."
      ],
      "correctAnswers": [1],
      "hint": "Consider how a spender gets permission to spend tokens from an owner's account.",
      "explanation": "The `approve()` function allows an owner to authorize a spender to withdraw tokens from the owner's account, up to a specified limit, enabling the spender to use `transferFrom()` to transfer tokens.",
      "chapter": "Interchain Token Transfer"
    },
    "121": {
      "question": "Why is it necessary to call the `approve()` function before transferring ERC-20 tokens to a smart contract?",
      "options": [
        "Because it sets the gas fee for the transaction.",
        "It is not necessary; tokens can be transferred without approval.",
        "To check the balance of the smart contract.",
        "To authorize the smart contract to transfer tokens from your account."
      ],
      "correctAnswers": [3],
      "hint": "Consider how a smart contract gets permission to spend tokens from your account.",
      "explanation": "The `approve()` function allows a user to authorize a smart contract to withdraw tokens from their account up to a specified limit. This enables the smart contract to use `transferFrom()` to transfer tokens on behalf of the user.",
      "chapter": "Interchain Token Transfer"
    },
    "122": {
      "question": "Why are native tokens wrapped into ERC-20 tokens like wAVAX or wETH?",
      "options": [
        "To increase their transaction speed on the blockchain.",
        "To reduce the supply of the native token.",
        "To represent native assets as ERC-20 tokens for compatibility with DeFi applications.",
        "To convert them into stablecoins pegged to fiat currencies."
      ],
      "correctAnswers": [2],
      "hint": "Consider how wrapping affects interoperability within the EVM ecosystem.",
      "explanation": "Wrapping native tokens into ERC-20 tokens allows them to conform to the ERC-20 standard, making them compatible with decentralized applications, exchanges, and smart contracts that require ERC-20 tokens. This enhances interoperability and usability within the blockchain ecosystem.",
      "chapter": "Interchain Token Transfer"
    },
    "123": {
      "question": "Which of the following best describes the 'Lock & Mint' mechanism in asset bridging?",
      "options": [
        "Locking assets on the source blockchain and minting equivalent tokens on the target blockchain.",
        "Burning assets on both the source and target blockchains simultaneously.",
        "Using custodians to manage and transfer assets between blockchains.",
        "Releasing assets without the need for smart contracts or locking mechanisms."
      ],
      "correctAnswers": [0],
      "hint": "Consider how assets are secured on one chain and represented on another.",
      "explanation": "In the 'Lock & Mint' mechanism, assets are locked in a smart contract on the source blockchain, and an equivalent amount of wrapped tokens are minted on the target blockchain. This allows the asset's value to be transferred and used on a different blockchain.",
      "chapter": "Interchain Token Transfer"
    },
    "124": {
      "question": "Which type of smart contract exploit allows attackers to repeatedly withdraw funds before the contract's state is updated?",
      "options": [
        "Reentrancy Attacks",
        "Arithmetic Errors",
        "Logic Flaws",
        "Phishing Attacks"
      ],
      "correctAnswers": [0],
      "hint": "Consider exploits involving recursive calls to a contract.",
      "explanation": "Reentrancy attacks exploit a contract's ability to call itself before the initial function call is completed, allowing attackers to repeatedly withdraw funds before the contract's state is updated.",
      "chapter": "Interchain Token Transfer"
    },
    "125": {
      "question": "Which statement is true about token transfers in the Avalanche Interchain Token Transfer Design?",
      "options": [
        "Only ERC20 tokens can be transferred; native tokens are not supported.",
        "Transfers must involve the same token type on both home and remote chains.",
        "Any combination of ERC20 and native tokens can be transferred between home and remote chains.",
        "Token transfers require approval from network administrators."
      ],
      "correctAnswers": [2],
      "hint": "Consider the flexibility of token types allowed in transfers.",
      "explanation": "The Avalanche Interchain Token Transfer Design supports transferring tokens with any combination of ERC20 and native tokens between home and remote chains, including ERC20 to ERC20, ERC20 to Native, Native to ERC20, and Native to Native.",
      "chapter": "Interchain Token Transfer"
    },
    "126": {
      "question": "What is the purpose of the `_tokenMultiplier` in the `TokenRemote` contract when bridging assets between chains with different decimal systems?",
      "options": [
        "It adjusts the token amount to match the decimal system of the target chain by multiplying or dividing as necessary.",
        "It locks the tokens on the source chain before transfer.",
        "It handles the minting of new tokens on the target chain.",
        "It calculates the transaction fees for cross-chain transfers."
      ],
      "correctAnswers": [0],
      "hint": "Consider how token amounts are scaled between chains with different decimal places.",
      "explanation": "The `_tokenMultiplier` is used to scale the token amounts when transferring between chains with different decimal systems. It is calculated based on the difference in decimals between the home and remote tokens and ensures that the token value remains consistent across chains.",
      "chapter": "Interchain Token Transfer"
    },
    "127": {
      "question": "Can there be multiple TokenRemotes for a single TokenHome?",
      "hint": "Think about how tokens are transferred between chains and where they originate from.",
      "options": [
        "Yes",
        "No"
      ],
      "correctAnswers": [0],
      "explanation": "Yes, there can be multiple TokenRemotes for a single TokenHome. This allows the same token to be bridged to multiple chains, enabling cross-chain interoperability and use cases across different blockchain networks.",
      "chapter": "Interchain Token Transfer"
    },
    "201": {
      "question": "Which function is used to allow another account to transfer tokens on your behalf?",
      "options": [
          "transfer()",
          "approve()",
          "transferFrom()",
          "allowance()"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "This function sets an approval limit for token transfers by a third party.",
      "explanation": "The approve() function allows another account to spend tokens on your behalf up to a specified amount.",
      "chapter": "ERC-20 Tokens"
  },
  "202": {
      "question": "What is the primary purpose of wrapping a native token into an ERC-20 token?",
      "options": [
          "To increase its supply",
          "To burn the native token",
          "To make the native token compatible with the ERC-20 standard",
          "To mint more native tokens"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Wrapping allows the native token to be used in decentralized applications that require ERC-20 tokens.",
      "explanation": "The wrapping process makes native tokens (like ETH, AVAX) compatible with the ERC-20 standard, enabling their use in dApps and DeFi protocols.",
      "chapter": "Wrapped Native Tokens"
  },
  "203": {
      "question": "What is the primary advantage of using a custom native token in a blockchain?",
      "options": [
          "It automatically increases in value over time",
          "It can only be used for test environments",
          "It eliminates the need for validators",
          "It allows for more control over transaction fees and tokenomics"
      ],
      "correctAnswers": [
          3
      ],
      "hint": "Custom native tokens give developers flexibility in managing blockchain economics.",
      "explanation": "A custom native token allows developers to control transaction fees, design tokenomics, and tailor the blockchain’s fee structure to meet specific needs.",
      "chapter": "Custom Native Tokens"
  },
  "204": {
      "question": "What is the AllowList used for when configuring the Native Minter Precompile?",
      "options": [
          "To set transaction fees for using the native token",
          "To control which addresses are allowed to mint native tokens",
          "To limit the total number of native tokens that can be minted",
          "To freeze minting of native tokens"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "The allow list determines which addresses have permission to interact with the precompiled contract.",
      "explanation": "The AllowList is used to specify which addresses have the permission to mint native tokens or manage the minting process.",
      "chapter": "Activating Native Minter Precompile"
  },
  "205": {
      "question": "What is the main advantage of a multi-chain ecosystem?",
      "options": [
          "It reduces the security of the blockchain.",
          "It increases the gas fees.",
          "It enables tokens and assets to be transferred across multiple blockchains.",
          "It restricts interoperability between different blockchains."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Think about the ability of assets and tokens to move freely across multiple chains.",
      "explanation": "The key benefit of a multi-chain ecosystem is that it allows tokens, assets, and data to be transferred between different blockchains, promoting interoperability.",
      "chapter": "Cross-Chain Ecosystems"
  },
  "206": {
      "question": "What role does Avalanche play in enabling multi-chain ecosystems?",
      "options": [
          "It provides a single-chain environment for transactions.",
          "It limits token usage to the native chain.",
          "It supports seamless cross-chain communication with tools like L1s and ICTT.",
          "It prevents interoperability between its L1s and other chains."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Avalanche is known for its ability to support cross-chain communication and interoperability through its architecture.",
      "explanation": "Avalanche's architecture, including its L1s and Interchain Token Transfers (ICTT), is designed to support seamless cross-chain communication and interoperability between different blockchain networks.",
      "chapter": "Cross-Chain Ecosystems"
  },
  "207": {
      "question": "Which contract must be granted minting rights for the ERC-20 token to be used as a native token on a new L1 chain?",
      "options": [
          "NativeTokenRemote contract",
          "ERC-20 Home contract",
          "ERC-712 contract",
          "L1 governance contract"
      ],
      "correctAnswers": [
          0
      ],
      "hint": "This contract mints native tokens on the destination chain after ERC-20 tokens are transferred.",
      "explanation": "The NativeTokenRemote contract must be granted minting rights to allow the native token to be minted on the new L1 after ERC-20 tokens are transferred from the source chain.",
      "chapter": "Use ERC-20 as Native Token"
  },
  "208": {
      "question": "Why is collateralization important in transferring native tokens between L1 chains?",
      "options": [
          "It increases the supply of tokens on the C-Chain.",
          "It ensures the total supply of tokens remains balanced across both chains.",
          "It burns the tokens on the remote chain.",
          "It locks the token permanently on the C-Chain."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Collateralization ensures balance across chains during token transfers.",
      "explanation": "Collateralization locks the transferred tokens on the source chain, ensuring that the minted tokens on the destination chain have an equivalent backing.",
      "chapter": "Use ERC-20 as Native Token"
  },
  "209": {
      "question": "What is the purpose of wrapping a native token on the C-Chain before transferring it to a new L1?",
      "options": [
          "To convert it into an ERC-721 token.",
          "To prepare it for cross-chain transfer as an ERC-20 token.",
          "To lock it in a smart contract and mint its representation on the new L1.",
          "To burn the token and reduce its total supply."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Wrapping a token creates a compatible version of it for cross-chain transfers.",
      "explanation": "Wrapping the native token locks it on the C-Chain, allowing a compatible version of the token to be minted on the new L1, ensuring the cross-chain token transfer process.",
      "chapter": "Use ERC-20 as Native Token"
    },
  "210": {
    "question": "Which function is used to initialize the Validator set in the ValidatorManager contract?",
    "options": [
        "initializeValidatorRegistration()",
        "deployProxyContract()",
        "initializeValidatorSet()",
        "setSubnetValidator()"
    ],
    "correctAnswers": [
        2
    ],
    "hint": "Initialization of the Validator set is a critical step in setting up the ValidatorManager.",
    "explanation": "The function `initializeValidatorSet` is called to initialize the Validator set in the ValidatorManager contract, setting up the starting Validators for the L1.",
    "chapter": "Staking"
  },
  "211": {
      "question": "Which configuration parameter sets the target rate of block production in seconds?",
      "options": [
          "minBaseFee",
          "targetBlockRate",
          "blockGasCostStep",
          "baseFeeChangeDenominator"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "This parameter defines how frequently blocks should be produced.",
      "explanation": "The `targetBlockRate` specifies the target rate of block production in seconds. For example, a target of 2 aims to produce a block every 2 seconds.",
      "chapter": "Transaction Fees"
    },
  "212": {
    "question": "Which allocation method ensures widespread ownership and participation in the network?",
      "options": [
          "Founders and Development Team",
          "Early Investors and Backers",
          "Community through token sales and airdrops",
          "Reserve or Treasury"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "This allocation focuses on distributing tokens to a broad group of network participants.",
      "explanation": "Allocating tokens to the community through mechanisms such as token sales and airdrops ensures widespread ownership and participation in the network, fostering decentralization and security.",
      "chapter": "Token Distribution"
  },
  "213": {
      "question": "What is the primary function of a bonding curve in token economics?",
      "options": [
          "To manage the governance of decentralized organizations.",
          "To set a fixed price for tokens regardless of supply.",
          "To define the relationship between a token's price and its supply, enabling automated price discovery and liquidity.",
          "To create a voting mechanism for token holders."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Bonding curves automate the price based on token supply.",
      "explanation": "A bonding curve defines the relationship between a token's price and its supply, enabling automated price discovery and liquidity without relying on traditional market makers or exchanges.",
      "chapter": "Token Distribution"
    },
  "214": {
      "question": "Which governance model combines both on-chain and off-chain elements to balance flexibility and automation?",
      "options": [
          "On-Chain Governance",
          "Off-Chain Governance",
          "Hybrid Governance",
          "DAO-Based Governance"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "This model integrates decision-making processes both on and off the blockchain.",
      "explanation": "Hybrid governance combines on-chain and off-chain elements, aiming to balance the transparency and automation of on-chain governance with the flexibility and qualitative considerations of off-chain governance.",
      "chapter": "Governance Models"
  },
  "215": {
      "question": "Which of the following is a primary benefit of DAOs in blockchain governance?",
      "options": [
          "Centralized decision-making",
          "Enhanced transparency through blockchain recording",
          "Reduced need for community participation",
          "Elimination of smart contracts"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "DAOs leverage blockchain technology to ensure openness and accountability.",
      "explanation": "DAOs enhance transparency by recording all proposals, votes, and decisions on the blockchain, ensuring an immutable and transparent governance process that fosters trust and encourages active participation.",
      "chapter": "Governance Models"
    },
    "301": {
      "question": "クロスブロックチェーン通信におけるメッセージの役割は何ですか？",
      "options": [
          "宛先チェーン上でデータを処理する。",
          "送信元チェーン情報、宛先チェーン情報、エンコードされたデータ、署名を含むデータ。",
          "送信元チェーンから通信を開始する。",
          "送信元上でメッセージの正当性を検証する。"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "メッセージは、送信元チェーンや宛先チェーンの情報を含む重要なデータをブロックチェーン間で送受信します。",
      "explanation": "クロスブロックチェーン通信におけるメッセージは、送信元チェーン、宛先チェーン、エンコードされたデータ、正当性を保証する署名を含みます。これにより、送付される情報が正確であり、宛先チェーンで信頼できることが保証されます。",
      "chapter": "Interchain Messaging"
    },
    "302": {
        "question": "マルチチェーンシステムは、シングルチェーンネットワークと比べてどのようにスケーラビリティを向上させていますか？",
        "options": [
            "単一のチェーンのガスリミットを増やす。",
            "独立したチェーンを並列に実行し、合計スループットを向上させる。",
            "単一のチェーン上でより複雑なスマートコントラクトを実装する。",
            "ネットワーク内のバリデータの数を減らす。"
        ],
        "correctAnswers": [
            1
        ],
        "hint": "マルチチェーンシステムは、並列処理を活用してネットワーク全体のパフォーマンスを向上させます。",
        "explanation": "マルチチェーンシステムは、独立したチェーンを並列に実行することでスケーラビリティを向上させます。この並列処理により、各チェーンが独自のトランザクションを処理でき、単一チェーンの制約に縛られることなくネットワーク全体の合計スループットを向上させることができます。",
        "chapter": "Interchain Messaging"
    },
    "303": {
        "question": "Solidity でデータのエンコードとデコードに使用される関数はどれですか？",
        "options": [
            "serializeData() と deserializeData()",
            "encodeData() と decodeData()",
            "abi.encode() と abi.decode()",
            "bytes.encode() と bytes.decode()"
        ],
        "correctAnswers": [
            2
        ],
        "hint": "これらの関数は Solidity の ABI エンコーディングとデコーディングの機能の一部です。",
        "explanation": "Solidity では、abi.encode()を使用してデータをバイト配列にエンコードし、abi.decode()を使用して元のデータ型にデコードします。これらの関数は、スマートコントラクト内で複雑なデータ構造を処理するために使用されます。",
        "chapter": "エンコーディング & デコーディング"
    },
    "304": {
        "question": "Interchain Messaging コントラクトで dApp がクロスチェーンメッセージを送信するために使用する関数の名前は何ですか？",
        "options": [
            "sendCrossChainMessage()",
            "sendCrossMessage()",
            "initiateCrossChainCommunication()",
            "sendMessageCrossChain()"
        ],
        "correctAnswers": [
            0
        ],
        "hint": "この関数は、チェーン間でメッセージを送信するための ITeleporterMessenger インターフェースの一部です。",
        "explanation": "sendCrossChainMessage()関数は、dApp が Interchain Messaging コントラクトを介してクロスチェーンメッセージを送信するために使用されます。この関数は TeleporterMessageInput 構造体を引数として受け取り、送信先チェーン ID、送信先アドレス、手数料情報、必要なガス上限、許可されたリレイヤー、エンコードされたメッセージなどの詳細を含みます。",
        "chapter": "メッセージの送信"
    },
    "305": {
        "question": "Interchain Messaging コントラクトからメッセージを受信するために、コントラクトが実装しなければならないインターフェースはどれですか？",
        "options": [
            "ITeleporterMessenger",
            "ITeleporterReceiver",
            "ITeleporterSender",
            "IMessageHandler"
        ],
        "correctAnswers": [
            1
        ],
        "hint": "このインターフェースは、クロスチェーンメッセージを受信するための関数を定義しています。",
        "explanation": "Interchain Messaging コントラクトからメッセージを受信するためには、ITeleporterReceiverインターフェースを実装する必要があります。このインターフェースにはreceiveTeleporterMessage関数が含まれており、受信したメッセージを処理するために使用されます。",
        "chapter": "メッセージの受信"
    },
    "306": {
      "question": "abi.encode() を使用して複数の値をバイト配列にエンコードした後、それを Solidity で正しくデコードするために必要な情報は何ですか？",
      "options": [
          "バイト配列の長さ",
          "コントラクトのアドレス",
          "エンコードされた値の型と順番",
          "使用されたエンコードアルゴリズム"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "デコードには、エンコード時に使用された元のデータ構造の情報が必要です。",
      "explanation": "abi.decode() を使用して Solidity でバイト配列を正しくデコードするには、エンコードされた値の型とその順番を正確に知る必要があります。これにより、バイト配列の各部分が適切に元の形式に変換されます。",
      "chapter": "エンコーディング & デコーディング"
    },
    "307": {
      "question": "クロスチェーンメッセージ内で関数を呼び出す際、`abi.encode()` 関数が 2 回呼ばれるのはなぜですか？",
      "options": [
          "メッセージのセキュリティを向上させるため。",
          "関数名とそのパラメータを 1 つのバイト配列にまとめるため。",
          "メッセージを 2 つの異なるバイト配列に分割するため。",
          "Teleporter コントラクトの要件に従うため。"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "関数名とそのパラメータを一緒にエンコードすることで、受信側が正しく識別・処理できるようになります。",
      "explanation": "abi.encode() を 2 回呼び出すことで最初に関数のパラメータをエンコードし、その後、関数名とエンコードされたパラメータをまとめてエンコードします。これにより、受信側のコントラクトが関数名をデコードして、適切な内部関数を特定して提供されたパラメータで処理できるようになります。",
      "chapter": "関数名とパラメータのエンコード"
    },
    "308": {
      "question": "TeleporterRegistry コントラクトは、異なるバージョンの TeleporterMessenger コントラクトをどのように管理していますか？",
      "options": [
          "コントラクトアドレスの配列を維持する。",
          "各バージョンごとに別々の変数を使用する。",
          "バージョン番号とコントラクトアドレスのマッピングを維持する。",
          "すべてのコントラクトアドレスを 1 つのバイト配列に保存する。"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "レジストリはキーと値の構造を使用して、バージョンと対応するコントラクトアドレスを関連付けています。",
      "explanation": "TeleporterRegistry コントラクトは、バージョン番号と対応するコントラクトアドレスをマッピングすることで、異なるバージョンの TeleporterMessenger コントラクトを管理しています。これにより、クロスチェーン Avalanche L1 dApp は最新バージョンまたは特定のバージョンの TeleporterMessenger を取得できます。",
      "chapter": "ICM レジストリの仕組み"
    },
    "309": {
      "question": "一部の署名スキームにおける `Recover` アルゴリズムの目的は何ですか？",
      "options": [
          "鍵ペアを生成するため。",
          "秘密鍵を使ってメッセージに署名するため。",
          "メッセージと署名から公開鍵を復元するため。",
          "メッセージの完全性を検証するため。"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "`Recover` アルゴリズムは、署名を作成する際に使用された公開鍵を復元するために使われます。",
      "explanation": "Recover アルゴリズムは、特定のメッセージとその署名から、それを作成した秘密鍵に対応する公開鍵を復元するために使用されます。これにより、受信者は復元された公開鍵と送信者の公開鍵を照合することで、メッセージの真正性と完全性を確認できます。",  
      "chapter": "署名スキーム"  
    },
    "310": {
      "question": "BLS マルチシグネチャスキームがブロックチェーンで特に優れている点は何ですか？",  
      "options": [  
          "すべての参加者が同じ秘密鍵を使用できる。",  
          "公開鍵が不要になる。",  
          "対称暗号を使用してセキュリティを強化している。",  
          "署名と公開鍵の集約が可能であり、コンパクトな署名を生成できる。"  
      ],  
      "correctAnswers": [  
          3  
      ],  
      "hint": "BLS スキームは、複数の署名を 1 つにまとめることができる点が特徴です。",  
      "explanation": "BLS（Boneh-Lynn-Shacham）マルチシグネチャスキームは、署名と公開鍵の **集約** をサポートしているため、ブロックチェーンにおいて非常に効率的です。複数の署名を 1 つの短い署名にまとめることができ、また、複数の公開鍵を 1 つに統合できるため、ストレージや通信コストを削減しつつ高いセキュリティとデータの整合性を維持できます。",  
      "chapter": "署名スキーム"  
    },
    "311": {  
      "question": "Avalanche ネットワークにおける P-Chain の主な役割は何ですか？",  
      "options": [  
          "Avalanche L1 のバリデーター登録とステーキング管理を行う。",  
          "スマートコントラクトの実行を管理する。",  
          "X-Chain 上のトランザクション処理を担当する。",  
          "異なるチェーン間の資産移転を促進する。"  
      ],  
      "correctAnswers": [  
          0  
      ],  
      "hint": "P-Chain はバリデーターの管理やステーキングを担当しています。",  
      "explanation": "Avalanche ネットワークでは、P-Chain が **バリデーター管理や Avalanche L1 レベルのオペレーション** を担当しています。これには、新しいブロックチェーンや Avalanche L1 の作成、バリデーターの追加、ステーキングの管理、その他のプラットフォームレベルの操作が含まれます。BLS 公開鍵の登録やステーキング管理を通じて、P-Chain はネットワークのセキュリティと機能性を確保します。",  
      "chapter": "P-Chain"  
    },
    "312": {  
      "question": "Avalanche ネットワークにおいて、クロスチェーンメッセージを宛先チェーンへリレーする役割を担うコンポーネントはどれですか？",  
      "options": [  
          "Warp Precompile",  
          "署名の検証",  
          "AWM リレイヤー",  
          "メッセージの初期化"  
      ],  
      "correctAnswers": [  
          2  
      ],  
      "hint": "このコンポーネントは送信元チェーンのメッセージを検出し、宛先チェーンに届ける役割を持ちます。",  
      "explanation": "AWM リレイヤー は、クロスチェーンメッセージを宛先チェーンへリレーする役割を担います。AWM リレイヤーは送信元の Avalanche L1 を定期的にチェックし、新しいメッセージがあれば、宛先 Avalanche L1 の Interchain Messaging コントラクトを呼び出して送付します。これにより、チェーン間で効率的にメッセージが送信されます。",  
      "chapter": "クロスチェーンメッセージのデータフロー"  
    },
    "313": {  
      "question": "Avalanche ネットワークの AWM リレイヤーは、新しい送信メッセージをどのように検出しますか？",  
      "options": [  
        "送信元チェーンを定期的にポーリングする、または通知によってトリガーされる。",  
        "バリデータからリアルタイムのアラートを受信する。",  
        "送信先チェーンのトランザクションレシートをスキャンする。",  
        "最新のブロックヘッダーのみを照会する。"  
      ],  
      "correctAnswers": [  
        0  
      ],  
      "hint": "AWM リレイヤーは、定期的なチェックまたはイベントベースのトリガーを使用します。",  
      "explanation": "AWM リレイヤーは、新しい送信メッセージを検出するために、送信元の Avalanche L1 を定期的にポーリングするか、ノードによって新しい送信メッセージが検出されたときに通知を受け取る方法を使用します。この 2 つのアプローチにより、メッセージが効率的に取得されて送信先チェーンにリレーされます。",  
      "chapter": "メッセージの取得"  
    },
    "314": {  
      "question": "なぜ AWM リレイヤーは BLS 公開鍵をオフチェーンで集約し、メッセージに添付しないのですか？",  
      "options": [  
          "オフチェーンで集約すると、メッセージサイズが大幅に増加するため。",  
          "AWM リレイヤーが不正な公開鍵や署名を作成するのを防ぎ、セキュリティを確保するため。",  
          "送信先チェーンがオフチェーンでの集約をサポートしていないため。",  
          "AWM リレイヤーの計算負荷を軽減するため。"  
      ],  
      "correctAnswers": [  
          1  
      ],  
      "hint": "公開鍵をオフチェーンで集約すると、リレイヤーが偽の署名を作成できる可能性があります。",  
      "explanation": "AWM リレイヤーが BLS 公開鍵をオフチェーンで集約してメッセージに添付しないのは、セキュリティ上のリスクを防ぐためです。もしオフチェーンで集約を行うと、リレイヤーが不正な公開鍵や署名を作成できる可能性があり、メッセージの真正性や整合性が損なわれる恐れがあります。送信先チェーンの各バリデータが公開鍵を集約することで、集約された公開鍵が実際に署名したバリデータのものであることが保証され、クロスチェーン通信の信頼性とセキュリティが維持されます。",  
      "chapter": "署名スキーム"  
    },
    "315": {
      "question": "Avalanche ネットワークの Interchain Messaging コントラクトに ERC-20 トークンをデポジットする主な目的は何ですか？",
      "options": [
          "トランザクションに関連するガス代を支払うため。",
          "ステーキング操作の担保として使用するため。",
          "AWM リレイヤーにメッセージ配信の報酬を提供し、インセンティブを与えるため。",
          "トークンをロックし、送付を防ぐため。"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "トークンのデポジットは、リレイヤーが業務を遂行するための経済的インセンティブとして機能します。",
      "explanation": "Interchain Messaging コントラクトに ERC-20 トークンをデポジットすることで、AWM リレイヤーに対する報酬メカニズムとして機能します。リレイヤーがメッセージを正常に配信すると、報酬としてデポジットされたトークンを請求できます。このインセンティブにより、クロスチェーンメッセージングの効率と安全性が維持されます。",
      "chapter": "手数料のデータフロー"
    },
    "316": {
      "question": "Avalanche ネットワークの手数料インセンティブモデルにおいて、リレイヤーが最低 10% の利益を確保するための最低手数料額はどのように計算されるべきですか？",
      "options": [
          "Fee = requiredGasLimit * gas_price_in_native_token",
          "Fee = (requiredGasLimit * gas_price_in_native_token) / 1.1",
          "Fee = requiredGasLimit + gas_price_in_native_token + native_token_price",
          "Fee = 1.1 * (requiredGasLimit * gas_price_in_native_token * native_token_price)"
      ],
      "correctAnswers": [
          3
      ],
      "hint": "手数料はコストをカバーし、リレイヤーに追加の利益を提供する必要があります。",
      "explanation": "リレイヤーが最低 10% の利益を得るためには、手数料額をコストの 1.1 倍として計算する必要があります。コストは requiredGasLimit に gas_price_in_native_token と native_token_price を掛けたものとして決定されるため、最低手数料は 1.1 * (requiredGasLimit * gas_price_in_native_token * native_token_price) となります。",
      "chapter": "手数料の決定"
    },
    "401": {
      "question": "What advantage do custom blockchains on Avalanche offer in terms of gas tokens compared to the C-Chain?",
      "options": [
          "They use a fixed gas token similar to ETH on the C-Chain.",
          "They eliminate the need for gas tokens altogether.",
          "They allow developers to use any ERC-20 token as the gas token.",
          "They automatically adjust gas fees based on network demand."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Custom blockchains offer flexibility in defining their gas tokens, unlike the C-Chain's fixed system.",
      "explanation": "Custom blockchains on Avalanche provide the flexibility to define their economic models, including the ability to use any ERC-20 token as their gas token. This differs from the C-Chain, which has a fixed gas token system (ETH). This flexibility allows developers to tailor the economic incentives and stability of their networks according to their specific needs.",
      "chapter": "Customizable Tokenomics"
    },
    "402": {
      "question": "How do Avalanche Custom Blockchains differ from Layer 2 rollups in terms of security and decentralization?",
      "options": [
          "Avalanche Custom Blockchains delegate security to the Ethereum mainnet, while Layer 2 rollups maintain independent security.",
          "Avalanche Custom Blockchains maintain their own security as part of the Avalanche base layer, whereas Layer 2 rollups delegate security to the Ethereum mainnet.",
          "Both Avalanche Custom Blockchains and Layer 2 rollups rely solely on the security of their respective base layers.",
          "Layer 2 rollups offer independent security for each blockchain, while Avalanche Custom Blockchains share a unified security model."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Avalanche Custom Blockchains are part of the base layer, while Layer 2 rollups rely on another mainnet for security.",
      "explanation": "Avalanche Custom Blockchains maintain their own security as part of the Avalanche base layer, ensuring that a compromise in one blockchain does not affect others. In contrast, Layer 2 rollups delegate their security to the Ethereum mainnet, meaning that if the Ethereum mainnet experiences a security breach, it can potentially impact all Layer 2 solutions relying on it.",
      "chapter": "Decentralization and Security"
    },
    "403": {
      "question": "What is the primary purpose of implementing dynamic transaction fees (gas fees) in the Ethereum network?",
      "options": [
          "To regulate access to limited processing resources and prevent network congestion.",
          "To reward developers for maintaining the network.",
          "To fund protocol upgrades and improvements.",
          "To incentivize liquidity providers."
      ],
      "correctAnswers": [
          0
      ],
      "hint": "Dynamic fees help manage the flow of transactions and avoid network overload.",
      "explanation": "Dynamic transaction fees, also known as gas fees, are implemented in the Ethereum network to regulate access to its limited processing resources. By adjusting fees based on network demand, Ethereum ensures that the blockchain remains efficient and prevents congestion, much like a flexible toll system on a highway manages traffic flow during peak hours.",
      "chapter": "Transaction Fees and Gas Fees"
    },
    "404": {
      "question": "Which interoperability use case on Avalanche allows users to transfer tokens like USDC across different Layer 1 blockchains without using centralized exchanges?",
      "options": [
          "Decentralized Data Feeds (Chainlink Price Feeds)",
          "Cross-Chain Token Transfers",
          "Cross-Chain NFTs",
          "Interoperable DeFi Protocols"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "This use case focuses on moving tokens seamlessly between different blockchain networks.",
      "explanation": "Cross-Chain Token Transfers enable users to move tokens such as USDC from one Layer 1 blockchain to another without the need for centralized exchanges or third-party intermediaries. This facilitates seamless transactions with minimal fees and fast processing times, enhancing liquidity access and maintaining decentralization by keeping users in control of their assets during the transfer.",
      "chapter": "Interoperability Use Cases"
    },
    "405": {
      "question": "What is the primary role of Avalanche's Interchain Messaging Protocol (ICM Protocol)?",
      "options": [
          "To facilitate the rapid transfer of assets between different Layer 1 blockchains.",
          "To manage validator sets and staking operations on Avalanche.",
          "To handle the creation of new blockchains and Avalanche L1s.",
          "To enable smart contracts on different chains to interact directly without intermediaries."
      ],
      "correctAnswers": [
          3
      ],
      "hint": "The ICM Protocol allows direct interaction between smart contracts on different chains.",
      "explanation": "The primary role of Avalanche's Interchain Messaging Protocol (ICM Protocol) is to enable smart contracts on different chains within the Avalanche network to interact with each other directly, without relying on third-party intermediaries. This facilitates complex cross-chain operations, enhancing the interoperability and functionality of the Avalanche ecosystem.",
      "chapter": "Interchain Messaging & the Interchain Messaging Protocol"
    },
    "406": {
      "question": "What is one of the primary benefits of implementing permissioning on an Avalanche L1 blockchain?",
      "options": [
          "Enhancing the decentralization by allowing anyone to participate.",
          "Increasing transaction speeds by reducing the number of validators.",
          "Ensuring data privacy and confidentiality by restricting access to authorized parties.",
          "Automatically adjusting gas fees based on network demand."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Permissioning helps in controlling who can access sensitive information on the blockchain.",
      "explanation": "One of the primary benefits of implementing permissioning on an Avalanche L1 blockchain is ensuring data privacy and confidentiality. By restricting access to authorized parties, permissioned blockchains protect sensitive information from unauthorized access, which is crucial in industries like finance and healthcare where data privacy is paramount.",
      "chapter": "Permissioning Your Avalanche L1"
    },
    "407": {
      "question": "How does permissioning on an Avalanche L1 blockchain help institutions comply with regulatory requirements?",
      "options": [
          "By allowing anyone to deploy contracts and initiate transactions.",
          "By enabling only pre-approved users to deploy contracts or initiate transactions.",
          "By automatically adjusting transaction fees based on user activity.",
          "By decentralizing control over smart contract deployments."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Permissioning restricts actions to authorized users to ensure compliance.",
      "explanation": "Permissioning on an Avalanche L1 blockchain allows institutions to enforce regulatory compliance by enabling only pre-approved users to deploy contracts or initiate transactions. This control ensures that only vetted and authorized parties can interact with the blockchain, thereby preventing unauthorized or potentially illicit activities. By restricting access, institutions can implement necessary measures such as KYC (Know Your Customer) and AML (Anti-Money Laundering) protocols, thereby adhering to industry-specific regulations and maintaining the integrity and security of their blockchain systems.",
      "chapter": "Compliance"
    },
    "408": {
      "question": "What is a primary benefit of implementing a permissioned validator set on an Avalanche L1 blockchain?",
      "options": [
          "It allows anyone to participate in the validation process, enhancing decentralization.",
          "It automatically adjusts transaction fees based on validator performance.",
          "It eliminates the need for validators by using a centralized authority.",
          "It restricts validation to pre-approved validators, ensuring compliance and security."
      ],
      "correctAnswers": [
          3
      ],
      "hint": "Permissioned validator sets provide control over who can validate transactions.",
      "explanation": "Implementing a permissioned validator set on an Avalanche L1 blockchain restricts the validation process to pre-approved validators. This enhances compliance with regulatory requirements, ensures higher security by limiting participation to trusted entities, and allows for better control over the network's governance and operations. Such a setup is particularly beneficial for enterprises, consortiums, government agencies, and financial institutions that require strict adherence to compliance and data privacy standards.",
      "chapter": "Permissioning Validators"
    },
    "409": {
      "question": "How can Avalanche L1 validators configure their blockchain to restrict data visibility only to validators?",
      "options": [
          "By setting their node to public mode.",
          "By enabling data encryption on the blockchain.",
          "By setting `validatorOnly` to true.",
          "By increasing gas fees."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Permissioned blockchains can limit data visibility to a select group.",
      "explanation": "Avalanche L1 validators can restrict data visibility by setting the `validatorOnly` flag to true on their nodes. This configuration ensures that only validators can exchange messages with the blockchain, preventing other peers from accessing the blockchain's data. This is essential for maintaining privacy and confidentiality in permissioned blockchains, especially in enterprise or regulated environments where data protection is paramount.",
      "chapter": "Private Blockchains"
    },
    "410": {
      "question": "How can a community running an Avalanche L1 blockchain maintain a hard cap on the native token supply?",
      "options": [
          "By keeping the Native Minter Precompile deactivated, preventing additional minting.",
          "By activating the Native Minter Precompile to allow unlimited minting.",
          "By setting the initial supply to 720 million AVAX and allowing periodic increases.",
          "By delegating minting rights to a centralized authority."
      ],
      "correctAnswers": [
          0
      ],
      "hint": "Maintaining a hard cap involves restricting the ability to mint new tokens.",
      "explanation": "To maintain a hard cap on the native token supply, a community running an Avalanche L1 blockchain should keep the Native Minter Precompile deactivated. By doing so, they prevent the creation of additional native tokens beyond the predefined limit. This ensures that the total supply remains fixed, which is essential for scenarios where a valueless gas token or a specific tokenomics structure is required. The Native Minter Precompile is deactivated by default, allowing blockchain creators to choose whether to enable or disable minting based on their economic models and requirements.",
      "chapter": "Native Token Minting Rights"
    }
  }
}